#' Extraction and regridding of GRIB data for multiple files for a given variable.
#' 
#' \code{RegridGRIB}: For a list of GRIB files, extract and regrid a variable
#' of a given vertical level to a WRF-Hydro domain.
#' 
#' @param files The files vector list
#' @param var The GRIB variable being regridded
#' @param levType Level type to extract GRIB data. Examples of levType would
#' be "surface", "cloudTop", "heightAboveGround"
#' @param lev The vertical level being regridded
#' @param wghtFile The weight regridding file. If it does not exist, it will 
#' be created.
#' @param geoFile The Geogrid LSM file needed for regridding.
#' @param method Method of regridding. Current acceptable values are 
#' "bilinear"
#' @param hrapFlag Optional HRAP flag to handle STAGE IV/II data.
#' @return A dataframe containing the regridded stack.
#' @keywords internal
#' @concept DBataRegrid
#' @family RegridMultiGRIB
#' @export
RegridGRIB <- function(files,var,levType,lev,wghtFile,geoFile,method,hrapFlag=0){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  
  #Check for a valid method
  if(method != "bilinear"){
    stop(paste0(method," regridding is not currently supported in this function."))
  }
  
  #Cast integer value for regridding method. This value will be used in the 
  #Fortran shared object to determine proper ESMF calls.
  if(method == "bilinear"){
    methodInt <- 1
  }
  #Calculate number of file steps
  nSteps <- length(files)
  
  #Extract metadata from the first GRIB file in the list. This information
  #will be used to establish input arrays into the regridding call.
  fileInit <- files[1]
  if(!file.exists(fileInit)){
    stop(paste0('ERROR: ',fileInit,' not found.'))
  }
  projection <- GRIBgridType(fileInit)
  geospatialDf <- GRIBgeospatial(projection,fileInit)
  
  #Extract number of 'forecast times per variable. For most cases, this
  #will be 1.
  numFTimes <- GRIBNumForecastTimes(fileInit,var,levType,lev)
  
  if (hrapFlag == 1){
    latLonGRIB <- HRAPLatLon(geospatialDf$NX,geospatialDf$NY,geospatialDf$DX,geospatialDf$LAT1,
                             geospatialDf$LON1,geospatialDf$LONV)
  } else {
    latLonGRIB <- GRIBLatLon(fileInit,geospatialDf$NX,geospatialDf$NY)
  }
  latGRIB <- latLonGRIB[,,1]
  lonGRIB <- latLonGRIB[,,2]
  
  #Flip data if south-north flag is not 1. Data is read north-south
  if(geospatialDf$SNFLAG == 0){
    latGRIB <- FlipLR(latGRIB)
    lonGRIB <- FlipLR(lonGRIB)
  }
  
  #Establish input data stack
  dataIn <- array(-9999.0,c(geospatialDf$NX,geospatialDf$NY,numFTimes,nSteps))
  
  #Establish date arrays
  cycleOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  verOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  bVerOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  
  #Loop through files and extract GRIB data for parent GRIB domain
  for(step in 1:length(files)){
    cycleOut[,step] <- as.POSIXct('1900-01-01')
    verOut[,step] <- as.POSIXct('1900-01-01')
    bVerOut[,step] <- as.POSIXct('1900-01-01')
    
    file <- files[step]
    dataTemp <- ExtractGRIBGrid(file,var,levType,lev,geospatialDf$NX,
                                geospatialDf$NY,numFTimes=numFTimes)
    #Flip if read in north-south
    for(fTime in 1:numFTimes){
      dataGrid <- as.matrix(dataTemp$data[,,fTime])
      if(geospatialDf$SNFLAG == 0){
        dataGrid <- FlipLR(dataGrid)
      }
      dataIn[,,fTime,step] <- dataGrid
      cycleOut[fTime,step] <- dataTemp$cycle[fTime]
      verOut[fTime,step] <- dataTemp$verTime[fTime]
      bVerOut[fTime,step] <- dataTemp$begVerTime[fTime]
    }
    #Establish metadata from 1st time step
    if(step == 1){
      longName <- dataTemp$longName
      units <- dataTemp$units
      ndv <- dataTemp$ndv
    }
    #Place date/time information into output arrays
  }
  #Check for existence of weight file. If it's not present, create one 
  #Using ESMF
  if(!file.exists(wghtFile)){
    #Note we are passing the first slice of GRIB data. This is used
    #conjunction with NDV information to generate a mask during the
    #weight generation.
    srcDummy <- array(ndv,c(geospatialDf$NX,geospatialDf$NY))
    srcDummy[,] <- dataIn[,,1,1]
    
    GenWghtFile(geoFile,geospatialDf$NX,geospatialDf$NY,latGRIB,lonGRIB,
                methodInt,srcDummy,ndv,wghtFile)
    #Double check to make sure file was created.
    if(!file.exists(wghtFile)){
      stop(paste0('ERROR: genWghtFile failed to create: ',wghtFile))
    }
  }
  #Regrid data stack
  dataOut <- Regrid(dataIn,latGRIB,lonGRIB,geoFile,methodInt,wghtFile,ndv)
  
  nxOut <- dim(dataOut)[1]
  nyOut <- dim(dataOut)[2]
  outList <- list(name=var,
                  longname=longName,
                  units=units,
                  precision = 'double',
                  missing=ndv,
                  dimensionList = 
                  list(
                          x=list(name='west_east',values=1:nxOut),
                          y=list(name='south_north',values=1:nyOut),
                          t=list(name='time',values=1:numFTimes),
                          f=list(name='files',values=1:length(files))),
                  data=dataOut,
                  cyclePOSIXct=cycleOut,
                  verifPOSIXct=verOut,
                  begVerifPOSIXct=bVerOut,
                  nativeFiles=files)
  
  outList
  
}

#' The RegridMultiGRIB for getting variables out of individual files.
#' 
#' \code{RegridMultiGRIBVar}: For a group of GRIB files, extract
#' and regrid a list of variables (for a specified level) to a WRF-Hydro domain.
#' 
#' @param varInd The variable index.
#' @param levTypeList The list of level types for each variable.
#' @param levList The vertical level list.
#' @param varList The variable list.
#' @param files The files vector.
#' @param wghtFile The weight file used for regridding.
#' @param geoFile The Geogrid LSM file for regridding.
#' @param method Method of regridding. Current acceptable values are 
#' "bilinear"
#' @param hrapFlag Optional HRAP flag to handle STAGE IV/II data.
#' @return A dataframe
#' @keywords internal
#' @keywords DataRegrid
#' @family RegridMultiGRIB
#' @export 
RegridMultiGRIBVar <- function(varInd, varList, levTypeList, levList, files,
                               wghtFile,geoFile,method,hrapFlag=0){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  #Length of levList and varList should be the same. A vertical level for
  #each variable in the GRIB file MUST be identified.
  if(length(varList) != length(levList)){
    stop("Length of the variable and levList are not equal.")
  }
  if(length(varList) != length(levTypeList)){
    stop("Length of the variable and levTypeList are not equal.")
  }
 
  #outList <- plyr::llply(ind, RegridGRIB,
  outList <-  RegridGRIB(var = varList[[varInd]],
                         levType = levTypeList[[varInd]],
                         lev = levList[[varInd]],
                         wghtFile = wghtFile,
                         geoFile = geoFile,
                         files = files,
                         method=method,hrapFlag=hrapFlag)
  outList
}





#' The RegridMultiGRIB for individual file groups.
#' 
#' \code{RegridMultiGRIBFile} : For this file group, regrid 
#' Regrid GRIB data spread over multiple files. Typically called
#' by RegridMultiGRIB.
#' 
#' @param fileInd The index of the file group.
#' @param fileList The list of the file group.
#' @param varList The variable list.
#' @param levTypeList The level type list.
#' @param levList The vertical level list.
#' @param wghtList The weight file list.
#' @param geoFile The geofile needed for regridding.
#' @param method Method of regridding. Current acceptable values are 
#' "bilinear".
#' @param hrapFlag Optional HRAP flag to handle STAGE IV/II data.
#' @return A dataframe
#' @keywords internal
#' @keywords DataRegrid
#' @keywords RegridMultiGRIB
#' @export
RegridMultiGRIBFile <- function(fileInd, fileList, varList, levTypeList,
                                levList,wghtList,geoFile,method,
                                hrapFlag=0){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  #Enforce collation at the variable-level level: (for this file group)
  #each variable has a co-located level index.
  if (length(varList) != length(levList)){
    stop(paste0("for file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level lists must be collated: their 
                lengths do not match."))
  }
  if (length(levTypeList) != length(varList)){
    stop(paste0("for file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level type lists must be collated: their
                lengths do not match."))
  }
  if (length(varList) != length(wghtList)){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and weight lists must be collagted: their
                lengths do not match."))
  }
  if (all(names(varList) != names(levList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level lists must be collated: their 
                names do not match."))
  }
  if (all(names(levTypeList) != names(varList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                 "The variable and level type lists must be collated: their
                 names do not match."))
  }
  if (all(names(varList) != names(wghtList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and weight type lists must be collated: their
                names do not match."))
  }
  varInd <- 1:length(varList[[fileInd]])
  
  #Check to make 1 and only 1 weight file per file group specified.
  if (length(wghtList[[fileInd]]) != 1){
    stop(paste0("ERROR: Only 1 weight file acceptable per file group. A 
                value of",length(wghtList[[fileInd]])," was found."))
  }
  outList <- plyr::llply(varInd, RegridMultiGRIBVar,
                         varList = varList[[fileInd]],
                         levTypeList = levTypeList[[fileInd]],
                         levList = levList[[fileInd]],
                         files = fileList[[fileInd]],
                         wghtFile = wghtList[[fileInd]][[1]],
                         geoFile = geoFile,
                         method=method,hrapFlag=hrapFlag)
  
  
  names(outList) <- names(varList[[fileInd]])
  outList
} 



#' Regrid multiple variables across various GRIB file groups to the
#' WRF-Hydro domain.
#' 
#' \code{RegridMultiGRIB} is designed to regrid multiple variables across
#' multiple GRIB files. Four collated lists specify 1) file groups,
#' 2) variables for each file group, 3) Level types for each variable group,
#' and 4) levels for each variable group. 
#' The names of the lists must match. 
#' In addition, a Geo LSM file must be presented for regridding to the
#' WRF-Hydro domain. Also, a regridding method must be provided to specify
#' how ESMF will regrid the data. Valid options currently include "bilinear".
#' See examples for details.
#' 
#' @param fileList The list of file groups. Names must match those in 
#'   the other lists.
#' @param varList The list of GRIB variables for each file group.
#'   Names must match fileList.
#' @param levTypeList The list of level types for each variable.
#' @param levList The list of GRIB levels for each variable group.
#'   Names must match fileList.
#' @param wghtList The list of weight files for each FILE group. If
#' you have two different groups of regridding files, you must specify
#' two different weight files. If they aren't found, they are created on 
#' the first iteration.
#' @param geoFile The path to the Geo LSM file used for regridding.
#' @param method Method of regridding. Current acceptable values are 
#' "bilinear".
#' @param hrapFlag Optional flag to handle STAGE IV/II projection
#' information. This is a patch due to the ECMWF GRIB API not
#' correctly extracting lat/lon information for the grid. 
#' @return A dataframe containing regridded data along with meta-data.
#' 
#' @examples
#' # This example shows extracting temperature, pressure, and downward
#' # shortwave radiation data at the surface from High Resolution Rapid
#' # Refresh GRIB data files.
#' \dontrun{
#' hrrrPath <- '/d4/karsten/data/HRRR/20151001'
#' GRIBFiles <- list.files(path=hrrrPath, pattern='hrrr.t00z.wrfnatf',
#'                         full.names=TRUE)
#' #fileList <- These are the groups of files.
#' fileList <- list(GRIBList1 = GRIBFiles)
#' #varList <- Define which variables are desired for each file group.
#' GRIBVars <- list(TEMPERATURE='2t', PRES='pres', DSWRF='dwsrf')
#' varList <- list(GRIBList1 = GRIBVars)
#' #levelTypeList <- Define type of vertical levels for each variables.
#' GRIBLevTypes <- list(levType='heightAboveGround',
#'                      levType='surface', levType='surface')
#' levTypeList <- list(GRIBList1 = GRIBLevTypes)
#' #levelList <- Define which vertical levels for each variable.
#' GRIBLevels <- list(level=0, level=0, level=0)
#' levelList <- list(GRIBList1 = GRIBLevels )
#' #wghtList <- Define which weight file for each file group.
#' weightFiles <- list(w1='./hrrr_ioc_1km_wghts.nc')
#' wghtList <- list(GRIBList1 = weightFiles )
#' geoFile <- '/d4/karsten/geospatial/geo_em.d01.nc'
#' regridData <- RegridMultiGRIB(fileList=fileList,varList=variableList,
#'                               levList=levelList,wghtList=wghtList,
#'                               geoFile=geoFile,'bilinear')
#' }
#' @export
RegridMultiGRIB <- function(fileList,varList,levTypeList,levList,
                            wghtList,geoFile,method,hrapFlag=0){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  ##Only do collated lists. Collation check at the file-variable-level level.
  if (length(varList) != length(levList) |
      length(varList) != length(fileList) |
      length(levList) != length(fileList) |
      length(fileList) != length(wghtList) |
      length(levTypeList) != length(fileList)){
    stop("The input lists must be collated: their lengths do not match.")
  }
  if (all(names(varList) != names(fileList)) |
      all(names(varList) != names(levList)) |
      all(names(levList) != names(fileList)) |
      all(names(fileList) != names(wghtList)) |
      all(names(levTypeList) != names(fileList))){
    stop("The input lists must be collated: their names do not match.")
  }
  fileInd <- 1:length(fileList)
  
  outList <- plyr::llply(fileInd,RegridMultiGRIBFile,
                         varList=varList,
                         levTypeList=levTypeList,
                         levList=levList,
                         fileList=fileList,
                         wghtList=wghtList,
                         geoFile=geoFile,
                         method=method,
                         hrapFlag=hrapFlag)
  
  names(outList) <- names(fileList)
  outList
}
