#' Extraction and regridding of GRIB data for multiple files for a given
#' variable to an unstructured mesh grid.
#' 
#' \code{RegridGRIB}: For a list of GRIB files, extract and regrid a variable
#' of a given vertical level to an unstructured mesh grid. 
#' 
#' @param files The files vector list
#' @param var The GRIB variables being regridded
#' @param levType Level type to extract GRIB data. Examples of LevType would
#' be "surface", "cloudTop", "heightAboveGround"
#' @param lev The vertical level being regridded
#' @param wghtFile The weight regridding file. If it does not exist, it will 
#' be created.
#' @param geoFile The geogrid LSM file needed for regridding.
#' @param uGridFile The UGRID file specifying the unstructured mesh.
#' @param method Method of regridding . Current acceptable values are
#' "bilinear"
#' @return A dataframe containing the regridded stack.
#' @keywords internal
#' @concept DataRegrid
#' @family RegridMultiGRIBToMesh
#' @export
RegridGRIBToMesh <- function(files,var,levType,lev,wghtFile,geoFile,
                             uGridFile,method){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  #Check for existence of UGRID file
  if(!file.exists(uGridFile)){
    stop(paste0('ERROR: ',uGridFile,' not found.'))
  }
  
  #Cast integer value for regridding method. This value will be used in the 
  #Fortran shared object to determine proper ESMF calls.
  if(method == "bilinear"){
    methodInt <- 1
  }
  #Calculate number of file steps
  nSteps <- length(files)
  
  #Extract metadata from the first GRIB file in the list. This information
  #will be used to establish input arrays into the regridding call.
  fileInit <- files[1]
  if(!file.exists(fileInit)){
    stop(paste0('ERROR: ',fileInit,' not found.'))
  }
  projection <- GRIBgridType(fileInit)
  geospatialDf <- GRIBgeospatial(projection,fileInit)
  
  #Extract number of 'forecast times per variable. For most cases, this
  #will be 1.
  numFTimes <- GRIBNumForecastTimes(fileInit,var,levType,lev)
  
  latLonGRIB <- GRIBLatLon(fileInit,geospatialDf$NX,geospatialDf$NY)
  latGRIB <- latLonGRIB[,,1]
  lonGRIB <- latLonGRIB[,,2]
  
  #Flip data if south-north flag is not 1. Data is read north-south
  if(geospatialDf$SNFLAG == 0){
    latGRIB <- FlipLR(latGRIB)
    lonGRIB <- FlipLR(lonGRIB)
  }
  
  #Establish input data stack
  dataIn <- array(-9999.0,c(geospatialDf$NX,geospatialDf$NY,numFTimes,nSteps))
  
  #Establish date arrays
  cycleOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  verOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  bVerOut <- data.frame(NA,matrix(nrow=numFTimes,ncol=nSteps))
  
  #Loop through files and extract GRIB data for parent GRIB domain
  for(step in 1:length(files)){
    cycleOut[,step] <- as.POSIXct('1900-01-01')
    verOut[,step] <- as.POSIXct('1900-01-01')
    bVerOut[,step] <- as.POSIXct('1900-01-01')
    
    file <- files[step]
    dataTemp <- ExtractGRIBGrid(file,var,levType,lev,geospatialDf$NX,
                                geospatialDf$NY,numFTimes=numFTimes)
    #Flip if read in north-south
    for(fTime in 1:numFTimes){
      dataGrid <- as.matrix(dataTemp$data[,,fTime])
      if(geospatialDf$SNFLAG == 0){
        dataGrid <- FlipLR(dataGrid)
      }
      dataIn[,,fTime,step] <- dataGrid
      cycleOut[fTime,step] <- dataTemp$cycle[fTime]
      verOut[fTime,step] <- dataTemp$verTime[fTime]
      bVerOut[fTime,step] <- dataTemp$begVerTime[fTime]
    }
    #Establish metadata from 1st time step
    if(step == 1){
      longName <- dataTemp$longName
      units <- dataTemp$units
      ndv <- dataTemp$ndv
    }
    #Place date/time information into output arrays
  }
  #Check for existence of weight file. If it's not present, create one 
  #Using ESMF
  if(!file.exists(wghtFile)){
    #Note we are passing the first slice of GRIB data. This is used 
    #in conjunction with NDV information to generate a mask during 
    #the weight generation.
    srcDummy <- array(ndv,c(geospatialDf$NX,geospatialDf$NY))
    srcDummy[,] <- dataIn[,,1,1]
    
    GenWghtFileMesh(geoFile,uGridFile,geospatialDf$NX,geospatialDf$NY,
                    latGRIB,lonGRIB,methodInt,srcDummy,ndv,wghtFile)
    #Double check to make sure file was created.
    if(!file.exists(wghtFile)){
      stop(paste0('ERROR: genWghtFile failed to create: ',wghtFile))
    }
  }
  
  #Regrid data stack
  dataOut <- Regrid(dataIn,latGRIB,lonGRIB,geoFile,methodInt,wghtFile,ndv)
    
  nxOut <- dim(dataOut)[1]
  nyOut <- dim(dataOut)[2]
  outList <- list(name=var,
                  longname=longName,
                  units=units,
                  precision = 'double',
                  missing=ndv,
                  dimensionList = 
                    list(
                      x=list(name='west_east',values=1:nxOut),
                      y=list(name='south_north',values=1:nyOut),
                      t=list(name='time',values=1:numFTimes),
                      f=list(name='files',values=1:length(files))),
                  data=dataOut,
                  cyclePOSIXct=cycleOut,
                  verifPOSIXct=verOut,
                  begVerifPOSIXct=bVerOut,
                  nativeFiles=files)
    
  outList
        
}

#' The RegridMultiGRIBToMesh for getting variables out of individual files.
#' 
#' \code{RegridMultiGRIBVarToMesh}: For a group of GRIB files, extract
#' and regrid a list of variables (for a specified level) to an 
#' unstructured mesh.
#' 
#' @param varInd The variable index.
#' @param levTypeList The list of level types for each variable.
#' @param levList The vertical level list.
#' @param varList The variable list.
#' @param files The files vector.
#' @param wghtFile The weight file used for regridding.
#' @param geoFile The geogrid LSM file for regridding.
#' @param uGridFile The UGRID file specifying the unstructured mesh.
#' @param method Method of regridding. Current acceptable values are 
#' "bilinear"
#' @return A dataframe
#' @keywords internal
#' @keywords DataRegrid
#' @family RegridMultiGRIBToMesh
#' @export
RegridMultiGRIBVarToMesh <- function(varInd, varList, levTypeList,
                                     levList, files, wghtFile,
                                     geoFile, uGridFile, method){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  #Check for existence of uGridFile
  if(!file.exists(uGridFile)){
    stop(paste0('ERROR: ',uGridFile,' not found.'))
  }
  #Length of levList and varList should be the same. A vertical level for
  #each variable in the GRIB file MUST be identified.
  if(length(varList) != length(levList)){
    stop("Length of the variable and levList are not equal.")
  }
  if(length(varList) != length(levTypeList)){
    stop("Length of the variable and levTypeList are not equal.")
  }
  
  outList <- RegridGRIBToMesh(var = varList[[varInd]],
                              levType = levTypeList[[varInd]],
                              lev = levList[[varInd]],
                              wghtFile = wghtFile,
                              geoFile = geoFile,
                              uGridFile = uGridFile,
                              files = files,
                              method = method)
  outList
}

#' The RegridMultiGRIBToMesh for individual file groups.
#' 
#' \code{RegridMultiGRIBFileToMesh} : For this file group, regrid
#' GRIB data spread over multiple files. Typically called
#' by RegridMultiGRIBToMesh.
#' 
#' @param fileInd The index of the file group.
#' @param fileList The list of the file group.
#' @param varList The variable list.
#' @param levTypeList The level type list.
#' @param levList The vertical level list.
#' @param wghtList The weight file list.
#' @param geoFile The geofile needed for regridding.
#' @param uGridFile The UGRID file specifying the destination mesh.
#' @param method Method of regridding. Current acceptable values are
#' "bilinear"
#' @return A dataframe
#' @keywords internal
#' @keywords DataRegrid
#' @keywords RegridMultiGRIBToMesh
#' @export
RegridMultiGRIBFileToMesh <- function(fileInd, fileList, varList, levTypeList,
                                      levList,wghtList,geoFile,uGridFile,
                                      method){
  #Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  #Check for existence of uGridFile
  if(!file.exists(uGridFile)){
    stop(paste0('ERROR: ',uGridFIle,' not found.'))
  }
  #Enforce collation at the variable-level level: (for this file group)
  #each variable has a co-located level index.
  if (length(varList) != length(levList)){
    stop(paste0("for file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level lists must be collated: their 
                lengths do not match."))
  }
  if (length(levTypeList) != length(varList)){
    stop(paste0("for file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level type lists must be collated: their
                lengths do not match."))
  }
  if (length(varList) != length(wghtList)){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and weight lists must be collagted: their
                lengths do not match."))
  }
  if (all(names(varList) != names(levList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level lists must be collated: their 
                names do not match."))
  }
  if (all(names(levTypeList) != names(varList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and level type lists must be collated: their
                 names do not match."))
  }
  if (all(names(varList) != names(wghtList))){
    stop(paste0("For file set ",names(fileList)[fileInd]," (#",fileInd,") ",
                "The variable and weight type lists must be collated: their
                names do not match."))
  }
  varInd <- 1:length(varList[[fileInd]])
  #Check to make 1 and only 1 weight file per file group specified.
  if (length(wghtList[[fileInd]]) != 1){
    stop(paste0("ERROR: Only 1 weight file acceptable per file group. A 
                value of",length(wghtList[[fileInd]])," was found."))
  }
  outList <- plyr::llply(varInd, RegridMultiGRIBVarToMesh,
                         varList = varList[[fileInd]],
                         levTypeList = levTypeList[[fileInd]],
                         levList = levList[[fileInd]],
                         files = fileList[[fileInd]],
                         wghtFile = wghtList[[fileInd]][[1]],
                         geoFile = geoFile,
                         uGridFile = uGridFile,
                         method = method)
  names(outList) <- names(varList[[fileInd]])
  outList
}

#' Regrid multiple variables across various GRIB file groups to an
#' unstructured mesh grid composed of polygons.
#' 
#' \code{RegridMultiGRIBToMesh} is designed to regrid multiple variables across
#' multiple GRIB files. Four collated lists specify 1) file groups,
#' 2) variables for each file group, 3) Level types for each variable group,
#' and 4) levels for each variable group.
#' The names of the lists must match.
#' In addition, a Geo LSM file, and a polygon shapefile must be present for 
#' regridding to the desired mesh grid. Also, a regridding method must be provided to specify 
#' how ESMF will regrid the data. Valid options currently include "bilinear". 
#' See examples for details.
#' 
#' @param fileList The list of file groups. Names must match those in 
#'  the other lists.
#' @param varList the list of GRIB variables for each file group.
#'  Names must match fileList.
#' @param levTypeList The list of level types for each variable.
#' @param levList The list of GRIB levels for each variable group.
#'  Names must match the fileLst.
#' @param wghtList The list of weight files for each FILE group. If
#'  you have two different groups of regridding files, you must specify 
#'  two different weight files. If they aren't found, they are created on
#'  the first iteration. 
#' @param geoFile The path to the Geo LSM file used for regridding.
#' @param shpPath The path to the polygon shapefile used to create 
#'  the destination mesh grid.
#' @param uGridPath The path to the UGRID file necessary for creation
#'  of mesh objections prior to regridding or weight generation. If 
#'  file does not exist, one will automatically be created.
#' @param method Method of regridding. Current acceptable values are 
#'  "bilinear".
#'  
#' @examples 
#' # This example shows extracting temperature, pressure, and downward
#' # shortwave radiation data at the surface from High Resolution Rapid
#' # Refresh GRIB data files.
#' \dontrun{
#' hrrrPath <- '/d4/karsten/data/HRRR/20151001'
#' GRIBFiles <- list.files(path=hrrrPath, pattern='hrrr.t00z.wrfnatf',
#'                         full.names=TRUE)
#' #fileList <- These are the groups of files.
#' fileList <- list(GRIBList1 = GRIBFiles)
#' #varList <- Define which variables are desired for each file group.
#' GRIBVars <- list(TEMPERATURE='2t', PRES='pres', DSWRF='dwsrf')
#' varList <- list(GRIBList1 = GRIBVars)
#' #levelTypeList <- Define which vertical levels for each variable.
#' GRIBLevTypes <- list(levType='heightAboveGround',
#'                      levType='surface', levType='surface')
#' levTypeList <- list(GRIBList1 = GRIBLevTypes)
#' #levelList - Define which vertical levels for each variable.
#' GRIBLevels <- list(level=0, level=0, level=0)
#' levelList <- list(GRIBList1 = GRIBLevels)
#' #wghtList <- Define which weight file for each file group.
#' weightFiles <- list(w1='./hrrr_nhdv2_co_wghts.nc')
#' wghtList <- list(GRIBList1 = weightFiles )
#' geoFile <- '/d4/karsten/geospatial/geo_em.d01.nc'
#' shpPath <- '/d4/karsten/geospatial/colorado_nhdv2.shp'
#' uGridPath <- '/d4/karsten/geospatial/colorado_nhdv2_UGRID.nc'
#' regridData <- RegridMultiGRIBToMesh(fileList=fileList,varList=varList,
#'                                     levList=levelList,wghtList=wghtList,
#'                                     geoFile=geoFile,shpPath=shpPath,
#'                                     uGridPath=uGridPath,'bilinear')
#' }
#' @export
RegridMultiGRIBToMesh <- function(fileList,varList,levTypeList,levList,
                                  wghtList,geoFile,shpPath,uGridPath,method){
  # Check for existence of GeoFile
  if(!file.exists(geoFile)){
    stop(paste0('ERROR: ',geoFile,' not found.'))
  }
  # Check for existence of shpPath
  if(!file.exists(shpPath)){
    stop(paste0('ERROR: ',shpPath,' not found'))
  }
  ##Only do collated lists. Collation check at the file-variable-level level.
  if (length(varList) != length(levList) |
      length(varList) != length(fileList) |
      length(levList) != length(fileList) |
      length(fileList) != length(wghtList) |
      length(levTypeList) != length(fileList)){
    stop("The input lists must be collated: their lengths do not match.")
  }
  if (all(names(varList) != names(fileList)) |
      all(names(varList) != names(levList)) |
      all(names(levList) != names(fileList)) |
      all(names(fileList) != names(wghtList)) |
      all(names(levTypeList) != names(fileList))){
    stop("The input lists must be collated: their names do not match.")
  }
  fileInd <- 1:length(fileList)
  
  # Check for existence of UGRID file necessary. If one does not exist, 
  # create one.
  if (!file.exists(uGridPath)){
    # Create UGRID file
    GenUgridFile(shpPath,uGridPath)
  }
  
  fileInd <- 1:length(fileList)
  
  outList <- plyr::llply(fileInd,RegridMultiGRIBFileToMesh,
                         varList=varList,
                         levTypeList=levTypeList,
                         levList=levList,
                         fileList=fileList,
                         wghtList=wghtList,
                         geoFile=geoFile,
                         uGridFile=uGridPath,
                         method=method)
  
  names(outList) <- names(fileList)
  outList
}